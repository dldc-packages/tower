/**
 * Docker Compose file generator
 *
 * Maps ResolvedService definitions to docker-compose service configurations.
 */

import { stringify as yamlStringify } from "@std/yaml/stringify";
import { ResolvedService } from "../core/services.ts";
import { logger } from "../utils/logger.ts";

/**
 * Generate docker-compose.yml content from resolved services
 */
export function generateCompose(services: ResolvedService[]): string {
  logger.info("Generating docker-compose.yml...");

  // Collect all named volumes from services
  const namedVolumes: Record<string, unknown> = {};
  for (const service of services) {
    if (service.volumes) {
      for (const vol of service.volumes) {
        if (vol.type === "named" && vol.name) {
          namedVolumes[vol.name] = {};
        }
      }
    }
  }

  // Map services to docker-compose format
  const composeServices: Record<string, unknown> = {};
  for (const service of services) {
    const serviceName = service.name;
    composeServices[serviceName] = serviceToCompose(service);
  }

  const compose = {
    services: composeServices,
    networks: {
      app_network: {
        driver: "bridge",
      },
    },
    volumes: namedVolumes,
  };

  return `# Generated by Tower - Do not edit manually\n${yamlStringify(compose)}`;
}

/**
 * Convert a ResolvedService to a docker-compose service definition
 */
function serviceToCompose(service: ResolvedService): Record<string, unknown> {
  const environment: Record<string, string> = service.kind === "app"
    ? {
      ...(service.env ?? {}),
      ...(service.secrets ?? {}),
      OTEL_EXPORTER_OTLP_ENDPOINT: "http://otel-lgtm:4318",
    }
    : {
      ...(service.env ?? {}),
    };

  const composeService: Record<string, unknown> = {
    image: service.imageDigest,
    networks: ["app_network"],
    restart: service.restart ?? "unless-stopped",
  };

  // Add environment variables if present
  if (Object.keys(environment).length > 0) {
    composeService.environment = Object.entries(environment).map(
      ([k, v]) => `${k}=${v}`,
    );
  }

  // Add ports if defined (infrastructure services only)
  if (service.ports && service.ports.length > 0) {
    composeService.ports = service.ports.map((p) => {
      const proto = p.protocol ? `/${p.protocol}` : "";
      return `${p.host}:${p.container}${proto}`;
    });
  }

  // Add volumes if defined
  if (service.volumes && service.volumes.length > 0) {
    composeService.volumes = service.volumes.map((vol) => {
      if (vol.type === "bind") {
        if (!vol.source) {
          throw new Error(`Bind volume for service "${service.name}" missing source`);
        }
        const roFlag = vol.readonly ? ":ro" : "";
        return `${vol.source}:${vol.target}${roFlag}`;
      } else {
        if (!vol.name) {
          throw new Error(`Named volume for service "${service.name}" missing name`);
        }
        return `${vol.name}:${vol.target}`;
      }
    });
  }

  // Add command if defined
  if (service.command && service.command.length > 0) {
    composeService.command = service.command;
  }

  // Add health check if defined
  const healthCheck = service.healthCheck;
  if (healthCheck) {
    const port = healthCheck.port ?? 80;
    const path = healthCheck.path ?? "";
    const interval = healthCheck.interval ?? 10;
    const timeout = healthCheck.timeout ?? 5;
    const retries = healthCheck.retries ?? 3;

    const testCmd = healthCheck.path
      ? ["CMD", "curl", "-f", `http://localhost:${port}${path}`]
      : ["CMD", "true"];

    composeService.healthcheck = {
      test: testCmd,
      interval: `${interval}s`,
      timeout: `${timeout}s`,
      retries,
    };
  }

  return composeService;
}
