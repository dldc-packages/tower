/**
 * Docker Compose file generator
 *
 * Maps ResolvedService definitions to docker-compose service configurations.
 */

import { stringify as yamlStringify } from "@std/yaml/stringify";
import { ResolvedService } from "../core/services.ts";
import { logger } from "../utils/logger.ts";

/**
 * Generate docker-compose.yml content from resolved services
 */
export function generateCompose(services: ResolvedService[]): string {
  logger.info("Generating docker-compose.yml...");

  // Collect all named volumes from services
  const namedVolumes: Record<string, unknown> = {};
  for (const service of services) {
    if (service.volumes) {
      for (const vol of service.volumes) {
        if (vol.type === "named" && vol.name) {
          namedVolumes[vol.name] = {};
        }
      }
    }
  }

  // Map services to docker-compose format
  const composeServices: Record<string, unknown> = {};
  for (const service of services) {
    const serviceName = service.name;
    composeServices[serviceName] = serviceToCompose(service);
  }

  const compose = {
    services: composeServices,
    networks: {
      app_network: {
        driver: "bridge",
      },
    },
    volumes: namedVolumes,
  };

  return `# Generated by Tower - Do not edit manually\n${yamlStringify(compose)}`;
}

/**
 * Convert a ResolvedService to a docker-compose service definition
 */
function serviceToCompose(service: ResolvedService): Record<string, unknown> {
  const environment: Record<string, string> = service.kind === "app"
    ? {
      ...(service.env ?? {}),
      ...(service.secrets ?? {}),
      OTEL_EXPORTER_OTLP_ENDPOINT: "http://otel-lgtm:4318",
    }
    : {
      ...(service.env ?? {}),
    };

  const composeService: Record<string, unknown> = {
    image: service.imageDigest,
    networks: ["app_network"],
    restart: service.restart ?? "unless-stopped",
  };

  // Add environment variables if present
  if (Object.keys(environment).length > 0) {
    composeService.environment = Object.entries(environment).map(
      ([k, v]) => `${k}=${v}`,
    );
  }

  // Get the first port from ingress for health checks and internal communication
  const ingressPort = getFirstIngressPort(service);

  // Add volumes if defined
  if (service.volumes && service.volumes.length > 0) {
    composeService.volumes = service.volumes.map((vol) => {
      if (vol.type === "bind") {
        if (!vol.source) {
          throw new Error(`Bind volume for service "${service.name}" missing source`);
        }
        const roFlag = vol.readonly ? ":ro" : "";
        return `${vol.source}:${vol.target}${roFlag}`;
      } else {
        if (!vol.name) {
          throw new Error(`Named volume for service "${service.name}" missing name`);
        }
        return `${vol.name}:${vol.target}`;
      }
    });
  }

  // Add command if defined
  if (service.command && service.command.length > 0) {
    composeService.command = service.command;
  }

  // Add health check if defined
  const healthCheck = service.healthCheck;
  if (healthCheck) {
    const port = healthCheck.port ?? ingressPort ?? 3000;
    const path = healthCheck.path ?? "";
    const interval = healthCheck.interval ?? 10;
    const timeout = healthCheck.timeout ?? 5;
    const retries = healthCheck.retries ?? 3;

    const testCmd = healthCheck.path
      ? ["CMD", "curl", "-f", `http://localhost:${port}${path}`]
      : ["CMD", "true"];

    composeService.healthcheck = {
      test: testCmd,
      interval: `${interval}s`,
      timeout: `${timeout}s`,
      retries,
    };
  }

  return composeService;
}

/**
 * Get the first port from ingress array, or undefined if no ingress
 */
function getFirstIngressPort(service: ResolvedService): number | undefined {
  // For infrastructure services, they still have the old domain/port structure temporarily
  const infraService = service as unknown as { ingress?: { port: number }[]; port?: number };
  if (infraService.ingress && infraService.ingress.length > 0) {
    return infraService.ingress[0].port;
  }
  // Fallback to old port field for infra services during migration
  if (infraService.port) {
    return infraService.port;
  }
  return undefined;
}
