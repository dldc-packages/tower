/**
 * Docker Compose file generator
 *
 * Maps ResolvedService definitions to docker-compose service configurations.
 */

import { stringify as yamlStringify } from "@std/yaml/stringify";
import type { ResolvedService } from "../core/types.ts";
import { logger } from "../utils/logger.ts";

/**
 * Generate docker-compose.yml content from resolved services
 */
export function generateCompose(services: ResolvedService[]): string {
  logger.info("Generating docker-compose.yml...");

  // Collect all named volumes from services
  const namedVolumes: Record<string, unknown> = {};
  for (const service of services) {
    if (service.volumes) {
      for (const vol of service.volumes) {
        if (vol.type === "named") {
          namedVolumes[vol.name] = {};
        }
      }
    }
  }

  // Map services to docker-compose format
  const composeServices: Record<string, unknown> = {};
  for (const service of services) {
    composeServices[service.name] = serviceToCompose(service);
  }

  const compose = {
    services: composeServices,
    networks: {
      app_network: {
        driver: "bridge",
      },
    },
    volumes: namedVolumes,
  };

  return `# Generated by Tower - Do not edit manually\n${yamlStringify(compose)}`;
}

/**
 * Convert a ResolvedService to a docker-compose service definition
 */
function serviceToCompose(service: ResolvedService): Record<string, unknown> {
  const environment: Record<string, string> = {
    ...service.env,
  };

  // Include secrets if present
  if (service.secrets) {
    Object.assign(environment, service.secrets);
  }

  const composeService: Record<string, unknown> = {
    image: service.image,
    networks: ["app_network"],
    restart: service.restart ?? "unless-stopped",
  };

  // Add environment variables if present
  if (Object.keys(environment).length > 0) {
    composeService.environment = Object.entries(environment).map(
      ([k, v]) => `${k}=${v}`,
    );
  }

  // Add ports if defined
  if (service.ports && service.ports.length > 0) {
    composeService.ports = service.ports.map((p) => {
      const proto = p.protocol ? `/${p.protocol}` : "";
      return `${p.host}:${p.container}${proto}`;
    });
  }

  // Add volumes if defined
  if (service.volumes && service.volumes.length > 0) {
    composeService.volumes = service.volumes.map((vol) => {
      if (vol.type === "bind") {
        const roFlag = vol.readonly ? ":ro" : "";
        return `${vol.source}:${vol.target}${roFlag}`;
      } else {
        return `${vol.name}:${vol.target}`;
      }
    });
  }

  // Add command if defined
  if (service.command && service.command.length > 0) {
    composeService.command = service.command;
  }

  // Add health check if defined
  if (service.healthCheck) {
    const port = service.port ?? 3000;
    const path = service.healthCheck.path ?? "";
    const interval = service.healthCheck.interval ?? 10;
    const timeout = service.healthCheck.timeout ?? 5;
    const retries = service.healthCheck.retries ?? 3;

    const testCmd = service.healthCheck.path
      ? ["CMD", "curl", "-f", `http://localhost:${port}${path}`]
      : ["CMD", "true"];

    composeService.healthcheck = {
      test: testCmd,
      interval: `${interval}s`,
      timeout: `${timeout}s`,
      retries,
    };
  }

  return composeService;
}
