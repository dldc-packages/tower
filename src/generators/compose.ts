/**
 * Docker Compose file generator
 *
 * Generate complete docker-compose.yml with infrastructure and app services.
 */

import type { Intent } from "@dldc/tower/types";
import { stringify as yamlStringify } from "@std/yaml/stringify";
import { DEFAULT_DATA_DIR, DEFAULT_PORT } from "../config.ts";
import { logger } from "../utils/logger.ts";

/**
 * Generate docker-compose.yml content
 */
export function generateCompose(intent: Intent, resolvedImages: Map<string, string>): string {
  logger.info("Generating docker-compose.yml...");

  const dataDir = intent.dataDir ?? DEFAULT_DATA_DIR;

  const services = {
    ...generateInfraServices(intent, dataDir),
    ...generateAppServices(intent, resolvedImages),
  };

  const compose = {
    version: "3.8",
    services,
    networks: {
      app_network: {
        driver: "bridge",
      },
    },
    volumes: {
      caddy_data: {},
      caddy_config: {},
      otel_lgtm_data: {},
      registry_data: {},
    },
  };

  return `# Generated by Tower - Do not edit manually\n${yamlStringify(compose)}`;
}

/**
 * Generate bootstrap docker-compose.yml for tower-only stack
 */
export function generateBootstrapCompose(dataDir: string, towerVersion: string): string {
  const compose = {
    version: "3.8",
    services: {
      tower: generateTowerService({
        version: towerVersion,
        dataDir,
        network: "tower_bootstrap",
        containerName: "tower",
        includeOtel: false,
      }),
    },
    networks: {
      tower_bootstrap: {
        name: "tower_bootstrap",
      },
    },
  } as const;

  return `# Generated by Tower - Bootstrap\n${yamlStringify(compose)}`;
}

/**
 * Generate tower service configuration
 */
function generateTowerService(options: {
  version: string;
  dataDir: string;
  network: string;
  containerName?: string;
  includeOtel?: boolean;
}): Record<string, unknown> {
  const environment = [
    `TOWER_DATA_DIR=${options.dataDir}`,
  ];

  if (options.includeOtel) {
    environment.push(
      "OTEL_EXPORTER_OTLP_ENDPOINT=http://otel-lgtm:4318/v1/traces",
      "OTEL_DENO=true",
      "OTEL_DENO_CONSOLE=capture",
    );
  }

  return {
    image: `ghcr.io/dldc-packages/tower:${options.version}`,
    environment,
    volumes: [
      `${options.dataDir}:${options.dataDir}`,
      "/var/run/docker.sock:/var/run/docker.sock",
    ],
    ...(options.containerName && { container_name: options.containerName }),
    networks: [options.network],
    restart: "unless-stopped",
    healthcheck: {
      test: ["CMD", "curl", "-f", `http://localhost:${DEFAULT_PORT}/status`],
      interval: "10s",
      timeout: "5s",
      retries: 3,
    },
  };
}

/**
 * Generate infrastructure services (Caddy, Tower, Registry, OTEL)
 */
function generateInfraServices(intent: Intent, dataDir: string): Record<string, unknown> {
  return {
    caddy: {
      image: "caddy:2",
      ports: ["80:80", "443:443"],
      volumes: [
        `${dataDir}/Caddy.json:/etc/caddy/Caddy.json:ro`,
        "caddy_data:/data",
        "caddy_config:/config",
      ],
      command: ["caddy", "run", "--config", "/etc/caddy/Caddy.json", "--adapter", "json"],
      networks: ["app_network"],
      restart: "unless-stopped",
    },

    tower: generateTowerService({
      version: intent.tower.version,
      dataDir,
      network: "app_network",
      includeOtel: true,
    }),

    registry: {
      image: "registry:2",
      environment: [
        "REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY=/var/lib/registry",
        "REGISTRY_STORAGE_DELETE_ENABLED=true",
      ],
      volumes: ["registry_data:/var/lib/registry"],
      networks: ["app_network"],
      restart: "unless-stopped",
      healthcheck: {
        test: ["CMD", "wget", "--spider", "-q", "http://localhost:5000/v2/"],
        interval: "10s",
      },
    },

    "otel-lgtm": {
      image: `grafana/otel-lgtm:${intent.otel.version}`,
      volumes: ["otel_lgtm_data:/data"],
      networks: ["app_network"],
      restart: "unless-stopped",
    },
  };
}

/**
 * Generate app services from intent
 */
function generateAppServices(
  intent: Intent,
  resolvedImages: Map<string, string>,
): Record<string, unknown> {
  const services: Record<string, unknown> = {};

  for (const app of intent.apps) {
    const image = resolvedImages.get(app.name) ?? app.image;

    const environment = {
      ...app.env,
      ...app.secrets,
      OTEL_EXPORTER_OTLP_ENDPOINT: "http://otel-lgtm:4318/v1/traces",
    };

    services[app.name] = {
      image,
      environment: Object.entries(environment).map(([k, v]) => `${k}=${v}`),
      networks: ["app_network"],
      restart: "unless-stopped",
      ...(app.healthCheck && {
        healthcheck: {
          test: app.healthCheck.path
            ? ["CMD", "curl", "-f", `http://localhost:${app.port ?? 3000}${app.healthCheck.path}`]
            : ["CMD", "true"],
          interval: `${app.healthCheck.interval ?? 10}s`,
          timeout: `${app.healthCheck.timeout ?? 5}s`,
          retries: app.healthCheck.retries ?? 3,
        },
      }),
    };
  }

  return services;
}
